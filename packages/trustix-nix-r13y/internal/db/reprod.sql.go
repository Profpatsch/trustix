// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: reprod.sql

package db

import (
	"context"
	"time"
)

const getDerivationReproducibility = `-- name: GetDerivationReproducibility :many
SELECT
  drv.drv,
  drvoutput.output,
  drvoutput.store_path,
  json_group_object(
    log.log_id,
    drvoutputresult.output_hash
  ) AS output_results
FROM
  derivationoutput AS drvoutput
  JOIN derivation drv ON drv.id = drvoutput.derivation_id
  LEFT JOIN derivationoutputresult drvoutputresult ON drvoutputresult.store_path = drvoutput.store_path
  LEFT JOIN log log ON log.id = drvoutputresult.log_id
  JOIN derivationrefrecursive refs_recurse ON refs_recurse.drv_id = drvoutput.derivation_id
  JOIN derivation referrer_drv ON referrer_drv.id = refs_recurse.referrer_id
WHERE
  referrer_drv.drv = ?
GROUP BY
  drvoutput.id
`

type GetDerivationReproducibilityRow struct {
	Drv           string
	Output        string
	StorePath     string
	OutputResults interface{}
}

func (q *Queries) GetDerivationReproducibility(ctx context.Context, drv string) ([]GetDerivationReproducibilityRow, error) {
	rows, err := q.db.QueryContext(ctx, getDerivationReproducibility, drv)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDerivationReproducibilityRow
	for rows.Next() {
		var i GetDerivationReproducibilityRow
		if err := rows.Scan(
			&i.Drv,
			&i.Output,
			&i.StorePath,
			&i.OutputResults,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDerivationReproducibilityTimeSeriesByAttr = `-- name: GetDerivationReproducibilityTimeSeriesByAttr :many
SELECT
  eval.id AS eval_id,
  eval.timestamp AS eval_timestamp,
  drv.drv,
  COUNT(drvoutput.id) AS output_count,
  COUNT(drvoutputresult.store_path) AS store_path_count,
  COUNT(drvoutputresult.output_hash) AS output_hash_count
FROM
  derivationoutput AS drvoutput
  JOIN evaluation eval ON eval.id = drveval.eval
  JOIN derivationeval drveval ON drveval.drv = drvoutput.derivation_id
  JOIN derivation drv ON drv.id = drvattr.derivation_id
  LEFT JOIN derivationoutputresult drvoutputresult ON drvoutputresult.store_path = drvoutput.store_path
  JOIN derivationrefrecursive refs_recurse ON refs_recurse.drv_id = drvoutput.derivation_id
  JOIN derivationattr drvattr ON drvattr.derivation_id = refs_recurse.referrer_id
WHERE
  drvattr.attr = ?
  AND eval.timestamp >= ?
  AND eval.timestamp <= ?
  AND eval.channel = ?
GROUP BY
  eval.id,
  drvattr.derivation_id
ORDER BY
  eval.timestamp
`

type GetDerivationReproducibilityTimeSeriesByAttrParams struct {
	Attr        string
	Timestamp   time.Time
	Timestamp_2 time.Time
	Channel     string
}

type GetDerivationReproducibilityTimeSeriesByAttrRow struct {
	EvalID          int64
	EvalTimestamp   time.Time
	Drv             string
	OutputCount     int64
	StorePathCount  int64
	OutputHashCount int64
}

func (q *Queries) GetDerivationReproducibilityTimeSeriesByAttr(ctx context.Context, arg GetDerivationReproducibilityTimeSeriesByAttrParams) ([]GetDerivationReproducibilityTimeSeriesByAttrRow, error) {
	rows, err := q.db.QueryContext(ctx, getDerivationReproducibilityTimeSeriesByAttr,
		arg.Attr,
		arg.Timestamp,
		arg.Timestamp_2,
		arg.Channel,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDerivationReproducibilityTimeSeriesByAttrRow
	for rows.Next() {
		var i GetDerivationReproducibilityTimeSeriesByAttrRow
		if err := rows.Scan(
			&i.EvalID,
			&i.EvalTimestamp,
			&i.Drv,
			&i.OutputCount,
			&i.StorePathCount,
			&i.OutputHashCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
