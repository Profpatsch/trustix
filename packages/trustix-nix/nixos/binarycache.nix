{ config, lib, pkgs, ... }:

let
  cfg = config.services.trustix-nix-cache;

  inherit (lib) mkOption mkIf types optional literalExpression;

in
{

  options.services.trustix-nix-cache = {

    enable = lib.mkEnableOption "Trustix Nix binary cache";

    package = mkOption {
      type = types.package;
      default = pkgs.trustix-nix;
      defaultText = literalExpression "pkgs.trustix-nix";
      description = "Which Trustix-Nix derivation to use.";
    };

    listen = mkOption {
      type = types.str;
      default = "127.0.0.1";
      example = "0.0.0.0";
      description = "The IP address to bind the trustix-nix-cache to.";
    };

    port = mkOption {
      type = types.port;
      default = 9001;
      description = "Which port to listen to.";
    };

    openFirewall = mkOption {
      type = types.bool;
      default = false;
      description = ''
        Open the appropriate ports in the firewall for trustix-nix-cache.
      '';
    };

    private-key = mkOption {
      type = types.path;
      description = "Which binary cache private key to use (generated by nix-store).";
    };

    trustix-rpc = mkOption {
      type = types.path;
      default = "/run/trustix-daemon.socket";
      description = "Which Trustix socket to connect to.";
    };

  };

  config = lib.mkIf cfg.enable {

    systemd.services.trustix-nix-cache = {
      description = "Trustix Nix binary cache daemon";
      wantedBy = [ "multi-user.target" ];
      requires = [ "trustix.socket" ];

      serviceConfig = {
        Type = "simple";
        ExecStart = "${lib.getBin cfg.package}/bin/trustix-nix binary-cache-proxy --address unix://${cfg.trustix-rpc} --listen ${cfg.listen}:${(toString cfg.port)} --privkey ${cfg.private-key}";
        DynamicUser = true;
      };
    };

    networking.firewall =
      mkIf cfg.openFirewall { allowedTCPPorts = [ ] ++ optional (cfg.listen != "127.0.0.1") cfg.port; };

  };

}
